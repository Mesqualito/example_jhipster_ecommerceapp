1.)
a.) for user-dev.csv and user-prod.csv look at https://github.com/jhipster/generator-jhipster/issues/6346
b.) for password-encryption see https://stackoverflow.com/questions/33859517/how-to-generate-encrypted-passwords-for-use-with-hipster
c.) How to create new users as admin: https://codefitter2.blogspot.com/2017/05/how-to-create-new-user-by-admin-in.html


2.)
for adding new roles in jhipster look at
- http://techknowblogs.blogspot.com/2016/12/adding-new-role-in-jhipster.html
- https://stackoverflow.com/questions/32436745/using-roles-in-jhipster?rq=1
- http://dgarceran.com/create-user-roles-jhipster-4-angular-2/
and especially in:
- https://github.com/jhipster/generator-jhipster/issues/1995
- https://github.com/deepu105/jhipster-roles
- https://groups.google.com/forum/#!topic/jhipster-dev/Z1dPMVX_nFA
- https://docs.spring.io/spring-security/site/docs/3.0.x/reference/domain-acls.html
- https://github.com/trevershick/shiken/tree/master/src/main/resources/config/liquibase
-


Additional Info:

add 1b.)

see https://auth0.com/blog/hashing-in-action-understanding-bcrypt/

bcrypt runs in two phases:
Phase 1:
A function called EksBlowfishSetup is setup using the desired cost, the salt, and the password
to initialize the state of eksblowfish. Then, bcrypt spends a lot of time running an expensive key schedule
which consists of performing a key derivation where we derive a set of subkeys from a primary key.
Here, the password is used as the primary key. In case that the user selected a bad or short password,
we stretch that password/key into a longer password/key. The aforementioned practice is also known as key stretching.

What we are going through this first phase is to promote key strengthening to slow down calculations which in turn also slow down attackers.

Phase 2:
The magic value is the 192-bit value OrpheanBeholderScryDoubt. This value is encrypted 64 times using eksblowfish in ECB mode
with the state from the previous phase. The output of this phase is the cost and the 128-bit salt value concatenated
with the result of the encryption loop.

The resulting hash is prefixed with $2a$, $2y$, or $2b$. The prefixes are added to indicate usage of bcrypt and its version.
The result of bcrypt achieves the three core properties of a secure password function as defined by its designers:
- It's preimage resistant.
- The salt space is large enough to mitigate precomputation attacks, such as rainbow tables.
- It has an adaptable cost (cost = work factor).

Test with Node.js script:
-------------------------------------------
const bcrypt = require('bcrypt');
const plainTextPassword1 = 'DFGh5546*%^__90';

for (let saltRounds = 10; saltRounds < 21; saltRounds++) {
    console.time(`bcrypt | cost: ${saltRounds}, time to hash`);
    bcrypt.hashSync(plainTextPassword1, saltRounds);
    console.timeEnd(`bcrypt | cost: ${saltRounds}, time to hash`);
}
-------------------------------------------


